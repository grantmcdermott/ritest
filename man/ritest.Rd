% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ritest.R
\name{ritest}
\alias{ritest}
\title{Perform randomization inference on a model object}
\usage{
ritest(
  object,
  resampvar,
  reps = 100,
  pvals = c("both", "left", "right"),
  strata = NULL,
  cluster = NULL,
  level = 0.95,
  parallel = TRUE,
  ptype = c("auto", "fork", "psock"),
  pcores = NULL,
  stack = NULL,
  stack_lim = 1L,
  seed = NULL,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{object}{Model object containing the `resampvar` variable. At present,
only `stats::lm` and `fixest::feols` models are supported.}

\item{resampvar}{Character or one-sided formula. The variable (coefficient)
that you want to conduct RI on. At present, only a single variable is
permitted.}

\item{reps}{Integer. The number of repetitions (permutation draws) in the RI
simulation. Default is 100, but you probably want more that that. Young
(2019) finds that rejection rates stabilise at around 2,000 draws.}

\item{pvals}{Character. How should the test values should be computed? The
default is "both", which means that two-sided p-values will be computed.
Alternatively, users can specify one-sided p-values with either "left" or
"right".}

\item{strata}{Character or one-sided formula. Permute `resampvar` within
strata (AKA blocks)? See Details and Examples below.}

\item{cluster}{Character or one-sided formula. Keep `resampvar` constant
within clusters? See Details and Examples below.#'}

\item{level}{Numeric. The desired confidence level. Default if 0.95.}

\item{parallel}{Logical. Should the permuted fits be executed in parallel?
Default is TRUE, with additional options being passed to the `ptype` and
`pcores` arguments.}

\item{ptype}{Character. What type of parallel strategy should be used? The
default behaviour on Linux and Mac is parallel forking ("fork"), while on
Windows it will revert to parallel sockets ("psock"). Note that forking
is more efficient, but unavailable on Windows.}

\item{pcores}{Integer. How many parallel cores should be used? If none is
provided, then it will default to half of the total available CPU cores
on the user's machine.}

\item{stack}{Logical. Should the permuted data be stacked in memory all at
once, rather than being recalculated during each iteration? Stacking takes
advantage of vectorisation and is thus more efficient. (It also helps to
ensure reproducibility when the results are being generated in parallel ---
see the note on random-number generation below.) But it does
require additional memory. If no explicit choice is provided, then the
function will automatically stack as long this implies an additional memory
overhead less than the `stack_lim` argument. (Note that stacking is only
relevant if at least one of `strata` or `cluster` are defined.)}

\item{stack_lim}{Numeric. What is the memory limit (in gigabytes) for
determining whether the permuted data should be stacked in memory ahead of
time? Default is 1 GB.}

\item{seed}{Integer. Random seed for reproducible results. Note that the
choice of parallel behaviour can alter results even when using the same
seed. See the note on random number generation below.}

\item{verbose}{Logical. Display the underlying model `object` summary and
`ritest` return value? Default is `FALSE`.}

\item{...}{Additional arguments. Currently ignored.}
}
\value{
An list object of class `ritest`. Default print and plotting methods
  are supported.
}
\description{
Perform randomization inference (RI) testing on a model object, e.g. a
  coefficient from a linear regression model. It tries to mimic the `ritest`
  Stata routine (Heß, 2017) in its design and functionality. The package is
  quite experimental and only a subset of this functionality is currently
  supported. However, it does appear to be significantly faster.
}
\details{
This function is experimental and functionality is still quite
  limited. Albeit, that it does support the most likely use case for RI on a
  regression model, i.e. permutation testing of a coefficient value. Present
  limitations include: only `lm` and `fixest::feols` model objects are
  supported; only one permutation (RI) test is allowed; and only one strata
  and/or cluster variable, respectively, can be supplied. I hope to resolve
  these limitations as time permits.
}
\note{
The use of parallelism in computation introduces some well-known
  complications with respect to random number generation (RNG). See the
  vignette accompanying the `parallel` package for more discussion. The
  `ritest()` function adopts various best practices to facilitate reliably
  reproducible results, irrespective of the choice of parallel strategy.
  These include the use of "L'Ecuyer-CMRG" RNG kind and the default behaviour
  of "stacking" the permuted results in memory before passing them on to the
  fitting stage of the randomization inference routine (where the fitting would
  still be done in parallel). To briefly dwell on the latter, note that this
  stacking behaviour is very similar to --- I nearly wrote "parallels" ---
  the approach adopted by `boot` and other packages that trade off RNG with
  parallelism and reproducibility. In the phrasing
  of the `parallel` vignette: "One way to avoid any difficulties is (where
  possible) to do all the randomization in the master process" (p. 5).

  The upshot is that running `ritest()` under a given set of arguments should
  generally yield the same, reproducible results regardless of when or where
  they were run. This should be true even if users turn the default parallel
  behaviour of the function off or back on, or whether they change the
  `ptype` argument to "psock" or "fork" and back again. However, it cannot be
  guaranteed under every scenario. Perhaps the most obvious case is when
  `ritest()` is run without any declared strata or clusters. (Reason:
  Stacking in this simple case is turned off because it yields no efficiency
  gains.) In this case, the RNG stream will be sensitive to the _number_ of
  available cores on a user's computer. Two parallel cores will yield a
  slightly different result than four cores, or six cores, etc. Of course,
  users can always ensure perfect reproducibility by explicitly defining the
  number of required cores in the `ritest()` call via the `pcores` argument.
  Stepping back, the focus on reproducible exactitude rather misses the
  point in an exercise like randomization inference testing. Much more important is
  running enough permutation trials so that your rejection rates are stable
  and any minor differences due to different RNG seeds are moot. Remember,
  the ultimate goal of inference (and research) isn't simply to generate
  reproducible results under a very specific set of circumstances. Rather, it
  is to generate consistent insights that hold even under varying
  circumstances.
}
\examples{
# Naive example using the inbuilt nkp dataset. See ?npk.

est = lm(yield ~ N + P + K, data = npk)

# Conduct RI on the 'N' (i.e. nitrogen) coefficient. We'll do 1,000 simulations
# and, just for illustration, limit the number of parallel cores to 2.
# The 'verbose = TRUE' argument simply prints the results upon completion,
# including the original regression model summary.

est_ri = ritest(est, 'N', reps = 1e3, seed = 1234L, pcores = 2L, verbose = TRUE)

# The RI rejection rate (0.021) is very similar to the parametric p-value (0.019).

# We can also plot the results and various options are available to
# customise the appearance.

plot(est_ri)
plot(est_ri, type = 'hist')
# etc

# More realistic example where we control for the stratified (aka "blocked")
# experimental design. We'll specify these strata (blocks) as fixed-effects
# in our regression model.

library(fixest) ## Aside: ritest requires fixest version >= 0.10.0
est2 = feols(yield ~ N + P + K | block, vcov = 'iid', data = npk)

# Re-do our RI from before, but this time permute within the 'block' strata.

est2_ri = ritest(est2, 'N', strata = 'block', reps = 1e3, seed = 99L, verbose = TRUE)

# Again, the RI rejection rate (0.003) is very similar to the parametric
# p-value (0.004) from the regression model. You probably want to increase
# the number of permutation reps for a real problem, though.

# Some asides...

# Formula interfaces are supported if you don't like writing variables (i.e.
# the treatment and/or strata and cluster arguments) as strings.

ritest(est2, ~N, strata = ~block, reps = 1e3, seed = 99L)

# If you don't like the default plot method and would prefer to use ggplot2,
# then that's easily done. Just extract the beta values from the return object.

library(ggplot2)
ggplot(data.frame(betas = est2_ri$betas), aes(betas)) + geom_density()

}
\references{
Simon Heß (2017). \cite{Robust Randomization inference with
  Stata: A guide and software}, The Stata Journal, 17, Number 3, pp. 630--651

Alwyn Young (2019). \cite{Channeling Fisher: Randomization
  Tests and the Statistical Insignificance of Seemingly Significant
  Experimental Results}, The Quarterly Journal of Economics, 134, Issue 2,
  pp. 557--598
}
\seealso{
[print.ritest()], [plot.ritest()]
}
